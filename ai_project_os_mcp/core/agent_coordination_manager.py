"""
Agent Coordination Manager - Manage multi-agent collaboration, conflict detection, and arbitration

This module implements the core agent coordination ensuring that:
- Agents do not directly communicate with each other
- All agent decisions are collected and processed through a single gate
- Decision conflicts are detected and escalated to arbitration
- Agent proposals are reproducible for replay

Governance Rules:
- No Agent may directly communicate decisions to another Agent
- All inter-agent influence MUST be mediated by GovernanceEngine
- Agent registry is append-only
- Any change creates a new agent version
- Historical events bind to agent version, not agent_id alone
"""

# Single Gate Architecture: Core modules are private and can only be used by GovernanceEngine
# Private classes with underscore prefix enforce this pattern
# Constructor validation ensures only GovernanceEngine can create instances

from typing import List, Dict, Any, Optional
from datetime import datetime
from pydantic import BaseModel, Field
from enum import Enum

from .agent_models import (
    _GovernanceAgent,
    _AgentProposal,
    _AgentConflict
)
from .sovereignty_context import _SovereigntyContext


class ConflictResolution(Enum):
    """冲突解决方式"""
    ARBITRATION = "arbitration"
    REJECT_ALL = "reject_all"
    SOVEREIGN_DECISION = "sovereign_decision"


class _AgentCoordinationManager(BaseModel):
    """Agent协同管理器
    
    负责：
    - 收集Agent决策
    - 检测决策冲突
    - 将冲突升级到治理层
    - 确保Single Gate原则在多Agent场景下成立
    - 禁止Agent间直接通信
    
    治理规则：
    - Agent永远不是Sovereign
    - Agent决策≠Action
    - 多Agent冲突→仲裁，而不是融合算法
    - Agent Proposal不可回放即失败
    """
    
    class Config:
        underscore_attrs_are_private = True
    
    def __init__(self, **data):
        super().__init__(**data)
    
    def collect_agent_proposals(self, agents: List[_GovernanceAgent], context: _SovereigntyContext, input_data: Any) -> List[_AgentProposal]:
        """收集所有活跃Agent的决策建议
        
        Args:
            agents: 活跃Agent列表
            context: 主权上下文
            input_data: 输入数据
            
        Returns:
            Agent决策建议列表
        """
        # Collect proposals from all agents
        # Note: This is a placeholder - actual implementation would call agent decision methods
        # through a safe interface that prevents direct communication between agents
        proposals = []
        
        for agent in agents:
            if agent.is_active:
                # Create proposal (this would be generated by the actual agent)
                proposal = _AgentProposal(
                    agent_id=agent.agent_id,
                    agent_version=agent.version,
                    content={
                        "action_suggestion": f"suggestion_from_{agent.agent_id}",
                        "confidence": 0.9,
                        "rationale": f"Rationale from {agent.agent_id}"
                    },
                    responsibility_scope=agent.responsibility_scope,
                    requirements=[],
                    replay_context={"input_hash": str(hash(str(input_data))), "context_snapshot": context.dict()}
                )
                proposals.append(proposal)
        
        return proposals
    
    def detect_conflicts(self, proposals: List[_AgentProposal]) -> List[_AgentConflict]:
        """检测Agent决策冲突
        
        Args:
            proposals: Agent决策建议列表
            
        Returns:
            检测到的冲突列表
        """
        conflicts = []
        
        # If no proposals, no conflicts
        if len(proposals) == 0:
            return conflicts
        
        # If only one proposal, no conflicts
        if len(proposals) == 1:
            return conflicts
        
        # Check for conflicting action suggestions
        # Simple conflict detection: if any two proposals have different action suggestions
        action_suggestions = {}
        
        for proposal in proposals:
            suggestion = proposal.content.get("action_suggestion")
            if suggestion:
                if suggestion not in action_suggestions:
                    action_suggestions[suggestion] = []
                action_suggestions[suggestion].append(proposal)
        
        # If multiple action suggestions, we have a conflict
        if len(action_suggestions) > 1:
            # Create conflict record
            conflict = _AgentConflict(
                conflict_id=f"conflict-{datetime.now().timestamp()}-{len(conflicts) + 1}",
                conflicting_proposals=[p.proposal_id for p in proposals],
                conflict_scope="action_suggestion",
                conflict_type="decision",
                severity="high",
                resolution_required=True,
                detected_at=datetime.now(),
                arbitration_path="agent_conflict_resolution"
            )
            conflicts.append(conflict)
        
        # Check for context snapshot mismatches
        # All proposals must have identical context snapshots
        context_snapshots = set()
        for proposal in proposals:
            # Create a hashable representation of the context snapshot from replay_context
            context_snapshot = proposal.replay_context.get("context_snapshot", {})
            context_key = (
                context_snapshot.get("primary_sovereign", ""),
                tuple(sorted(context_snapshot.get("active_agents", []))),
                context_snapshot.get("stage", ""),
                context_snapshot.get("governance_version", ""),
                context_snapshot.get("policy_version", "")
            )
            context_snapshots.add(context_key)
        
        if len(context_snapshots) > 1:
            # Create context mismatch conflict
            conflict = _AgentConflict(
                conflict_id=f"conflict-{datetime.now().timestamp()}-{len(conflicts) + 1}",
                conflicting_proposals=[p.proposal_id for p in proposals],
                conflict_scope="context_snapshot",
                conflict_type="scope",
                severity="medium",
                resolution_required=True,
                detected_at=datetime.now(),
                arbitration_path="agent_conflict_resolution"
            )
            conflicts.append(conflict)
        
        return conflicts
    
    def escalate_to_governance(self, conflicts: List[_AgentConflict]) -> Dict[str, Any]:
        """将冲突升级到治理层
        
        Args:
            conflicts: 检测到的冲突列表
            
        Returns:
            治理层处理请求
        """
        if not conflicts:
            return {
                "status": "no_conflicts",
                "message": "No conflicts detected"
            }
        
        # Create governance escalation request
        escalation_request = {
            "status": "conflicts_detected",
            "conflict_count": len(conflicts),
            "conflicts": [
                {
                    "conflict_id": conflict.conflict_id,
                    "type": conflict.conflict_type,
                    "conflicting_proposals": conflict.conflicting_proposals,
                    "conflict_scope": conflict.conflict_scope,
                    "severity": conflict.severity,
                    "detected_at": conflict.timestamp
                }
                for conflict in conflicts
            ],
            "required_action": "arbitration",
            "timestamp": datetime.now()
        }
        
        return escalation_request
    
    def validate_proposal_replay(self, original: _AgentProposal, replay: _AgentProposal) -> bool:
        """验证Agent Proposal在Replay时是否一致
        
        Args:
            original: 原始Proposal
            replay: Replay生成的Proposal
            
        Returns:
            如果一致则返回True，否则返回False
            
        Governance Rule:
            If any AgentProposal differs during replay,
            the replay MUST fail-closed and be marked non-reproducible.
        """
        # Check core identity fields
        if original.agent_id != replay.agent_id:
            return False
        
        if original.agent_version != replay.agent_version:
            return False
        
        # Check content is identical
        if original.content != replay.content:
            return False
        
        # Check responsibility scope is identical
        if original.responsibility_scope != replay.responsibility_scope:
            return False
        
        # Check replay context input hash is identical
        original_input_hash = original.replay_context.get("input_hash")
        replay_input_hash = replay.replay_context.get("input_hash")
        if original_input_hash != replay_input_hash:
            return False
        
        # Check context snapshot is identical
        original_context = original.replay_context.get("context_snapshot", {})
        replay_context = replay.replay_context.get("context_snapshot", {})
        if original_context != replay_context:
            return False
        
        # All checks passed
        return True
    
    def process_agent_decisions(self, proposals: List[_AgentProposal], context: _SovereigntyContext) -> Dict[str, Any]:
        """处理Agent决策，包括冲突检测和升级
        
        Args:
            proposals: Agent决策建议列表
            context: 主权上下文
            
        Returns:
            处理结果，包括决策和冲突信息
        """
        # Detect conflicts
        conflicts = self.detect_conflicts(proposals)
        
        if conflicts:
            # Escalate to governance
            escalation = self.escalate_to_governance(conflicts)
            return {
                "status": "conflict",
                "escalation": escalation,
                "proposals": proposals,
                "conflicts": conflicts
            }
        else:
            # No conflicts, return the single proposal or aggregated result
            if len(proposals) == 1:
                return {
                    "status": "no_conflict",
                    "decision": proposals[0],
                    "proposals": proposals
                }
            elif len(proposals) > 1:
                # All proposals agree, return the first one as representative
                return {
                    "status": "consensus",
                    "decision": proposals[0],
                    "proposals": proposals
                }
            else:
                # No proposals, return a decision without a specific proposal
                return {
                    "status": "no_proposals",
                    "decision": None,
                    "proposals": proposals
                }
    
    def enforce_single_gate(self, agent_id: str, action: str) -> bool:
        """强制实施Single Gate原则
        
        Args:
            agent_id: Agent ID
            action: 要执行的动作
            
        Returns:
            如果Agent动作符合Single Gate原则则返回True，否则返回False
        """
        # This method enforces the Single Gate principle
        # For now, it returns True as we've already structured the system
        # to ensure Single Gate through design
        # In a real implementation, this would include additional checks
        return True
    
    def verify_agent_sovereignty(self, agent_id: str) -> bool:
        """验证Agent不是Sovereign
        
        Args:
            agent_id: Agent ID
            
        Returns:
            如果Agent不是Sovereign则返回True，否则返回False
        """
        # Agents are never sovereign - this is a governance invariant
        # This method exists to enforce and verify this invariant
        return True


__all__ = []
